"use client";

import * as React from "react";
import { useAuth } from "@/hooks/use-auth";
import { useEffect } from "react";
import { useRouter } from "next/navigation";
import {
  Sidebar,
  SidebarProvider,
  SidebarInset,
} from "@/components/ui/sidebar";
import { DashboardHeader } from "@/components/dashboard/header";
import { DashboardControls } from "@/components/dashboard/dashboard-controls";
import { DashboardStats } from "@/components/dashboard/dashboard-stats";
import { DataFilters } from "@/components/dashboard/data-filters";
import { ExportOptions } from "@/components/dashboard/export-options";
import { ComparisonTool } from "@/components/dashboard/comparison-tool";
import { PollutionCharts } from "@/components/dashboard/pollution-charts";
import { ResultsTable } from "@/components/dashboard/results-table";
import { SummaryCard } from "@/components/dashboard/summary-card";
import { GeographicMap } from "@/components/dashboard/geographic-map";
import { Skeleton } from "@/components/ui/skeleton";
import type { PollutionData, RawPollutionData } from "@/lib/data";
import { demoData } from "@/lib/data";
import { calculateIndices } from "@/ai/flows/calculate-indices";
import { categorizePollutionRisk } from "@/ai/flows/categorize-pollution-risk";
import { summarizeDatasetInsights } from "@/ai/flows/summarize-dataset-insights";
import { generateReport } from "@/ai/flows/generate-report";
import {
  whoPermissibleLimits,
  bisPermissibleLimits,
  metalWeights,
  idealLimits,
  whoRiskLimits,
  bisRiskLimits,
} from "@/lib/standards";
import { useToast } from "@/hooks/use-toast";
import { downloadFile } from "@/lib/utils";
import { db } from "@/lib/firebase";
import { collection, addDoc, serverTimestamp } from "firebase/firestore";
import { jsPDF } from "jspdf";

export default function DashboardPage() {
  const { user, loading } = useAuth();
  const router = useRouter();
  const [rawData, setRawData] = React.useState<RawPollutionData[]>(demoData);
  const [processedData, setProcessedData] = React.useState<PollutionData[]>([]);
  const [filteredData, setFilteredData] = React.useState<PollutionData[]>([]);
  const [selectedStandard, setSelectedStandard] = React.useState("who");
  const [selectedLocation, setSelectedLocation] = React.useState<
    PollutionData | undefined
  >();
  const [summary, setSummary] = React.useState("");
  const [loadingData, setLoadingData] = React.useState(true);
  const [exporting, setExporting] = React.useState(false);
  const { toast } = useToast();

  useEffect(() => {
    if (!loading && !user) {
      router.push("/home");
    }
  }, [user, loading, router]);

  React.useEffect(() => {
    processData();
  }, [rawData, selectedStandard]);

  React.useEffect(() => {
    setFilteredData(processedData);
  }, [processedData]);

  const handleFileUpload = (data: RawPollutionData[]) => {
    setRawData(data);
  };

  const createFallbackReport = (data: PollutionData[], standard: string, summary: string) => {
  const timestamp = new Date().toLocaleString();
  const highRiskCount = data.filter(d => d.risk === 'High Risk').length;
  const moderateRiskCount = data.filter(d => d.risk === 'Moderate').length;
  const lowRiskCount = data.filter(d => d.risk === 'Safe').length;
    
    return `# Aqua Index Analysis Report

**Generated:** ${timestamp}  
**Standard:** ${standard.toUpperCase()}  
**Total Samples:** ${data.length}

## Executive Summary
${summary || 'Analysis completed successfully with the following results.'}

## Risk Assessment Summary
- **High Risk Locations:** ${highRiskCount}
- **Moderate Risk Locations:** ${moderateRiskCount}  
- **Low Risk Locations:** ${lowRiskCount}

## Sample Data
| Location | HPI | HEI | PLI | Risk Level |
|----------|-----|-----|-----|------------|
${data.map(d => `| ${d.location} | ${d.hpi.toFixed(2)} | ${d.hei.toFixed(2)} | ${d.pli.toFixed(2)} | ${d.risk} |`).join('\n')}

## Analysis Notes
This report was generated using the ${standard.toUpperCase()} standard for heavy metal pollution assessment. The data includes calculations for Heavy Metal Pollution Index (HPI), Heavy Metal Evaluation Index (HEI), and Pollution Load Index (PLI).

---
*Report generated by Aqua Index Analyzer*
`;
  };

  const handleExport = async (options: any) => {
    if (filteredData.length === 0) {
      toast({
        title: "No data to export",
        description: "Please upload and process data before exporting.",
        variant: "destructive",
      });
      return;
    }
    setExporting(true);
    try {
      console.log("Starting report generation with options:", options);
      console.log("Filtered data length:", filteredData.length);
      console.log("Summary length:", summary.length);
      
      let reportOutput;
      try {
        reportOutput = await generateReport({
          processedData: JSON.stringify(filteredData),
          summary: summary || "No summary available",
          selectedStandard: selectedStandard.toUpperCase(),
        });
        console.log("Report generated successfully:", reportOutput);
      } catch (aiError) {
        console.warn("AI report generation failed, creating fallback report:", aiError);
        // Create a simple fallback report
        const fallbackReport = createFallbackReport(filteredData, selectedStandard, summary);
        reportOutput = { report: fallbackReport };
      }
      
      const timestamp = new Date().toISOString();
      const filename = options.customTitle 
        ? `${options.customTitle.replace(/[^a-zA-Z0-9]/g, '_')}-${timestamp}.${options.format}`
        : `aqua-index-report-${timestamp}.${options.format}`;
      
      if (options.format === 'pdf') {
        // Generate a real PDF using jsPDF
        const doc = new jsPDF();
        // Split the report into lines for multi-line text
        const lines = reportOutput.report.split('\n');
        let y = 10;
        lines.forEach(line => {
          doc.text(line, 10, y);
          y += 8; // Move down for next line
          if (y > 280) {
            doc.addPage();
            y = 10;
          }
        });
        doc.save(filename);
      } else {
        const mimeType = options.format === 'csv' ? 'text/csv' : 
                        options.format === 'json' ? 'application/json' : 
                        options.format === 'md' ? 'text/markdown' : 'text/plain';
        downloadFile(reportOutput.report, filename, mimeType);
      }
      // Store report metadata to Firestore
      try {
        await addDoc(collection(db(), "reports"), {
          name: filename,
          format: options.format,
          size: reportOutput.report.length,
          samples: filteredData.length,
          createdAt: serverTimestamp(),
        });
      } catch (firestoreError) {
        console.warn("Failed to save report metadata:", firestoreError);
      }
      toast({
        title: "Report Generated",
        description: `Your ${options.format.toUpperCase()} report has been downloaded.`,
      });
    } catch (error) {
      console.error("Error generating report:", error);
      console.error("Error details:", {
        message: error instanceof Error ? error.message : 'Unknown error',
        stack: error instanceof Error ? error.stack : undefined,
        options,
        dataLength: filteredData.length,
        summaryLength: summary.length
      });
      toast({
        title: "Error Generating Report",
        description: `Failed to generate the report: ${error instanceof Error ? error.message : 'Unknown error'}`,
        variant: "destructive",
      });
    } finally {
      setExporting(false);
    }
  };

  async function processData() {
    if (rawData.length === 0) {
      setProcessedData([]);
      setSummary("No data to process. Please upload a file.");
      setSelectedLocation(undefined);
      setLoadingData(false);
      return;
    }
    setLoadingData(true);
    try {
      console.log("Starting data processing...");
      console.log("Raw data length:", rawData.length);
      console.log("Selected standard:", selectedStandard);
      // 1. Calculate Indices
      const permissibleLimits =
        selectedStandard === "who" ? whoPermissibleLimits : bisPermissibleLimits;
      console.log("Permissible limits:", permissibleLimits);
      console.log("Raw data sample:", rawData[0]);

      // Defensive: check for required metal fields in rawData
      const missingFields = rawData.length > 0 ? [
        ...rawData[0].As === undefined ? ["As"] : [],
        ...rawData[0].Cd === undefined ? ["Cd"] : [],
        ...rawData[0].Cr === undefined ? ["Cr"] : [],
        ...rawData[0].Pb === undefined ? ["Pb"] : [],
        ...rawData[0].Zn === undefined ? ["Zn"] : [],
      ] : [];
      if (missingFields.length > 0) {
        toast({
          title: "Missing Data Columns",
          description: `The following required fields are missing in your data: ${missingFields.join(", ")}`,
          variant: "destructive",
        });
        setLoadingData(false);
        return;
      }

      const indicesOutput = await calculateIndices({
        metalConcentrations: rawData.map(d => ({
          As: d.As,
          Cd: d.Cd,
          Cr: d.Cr,
          Pb: d.Pb,
          Zn: d.Zn,
        })),
        permissibleLimits,
        idealLimits,
        metalWeights,
      });
      console.log("Indices calculated successfully:", indicesOutput);

      // 2. Categorize Risk for all locations in a batch
      const riskInputs = indicesOutput.results.map((result, index) => {
        const cfValues = Object.values(result.cf);
        const averageCf = cfValues.reduce((a, b) => a + b, 0) / cfValues.length;
        return {
          id: rawData[index].id,
          hpi: result.hpi,
          hei: result.hei,
          cf: averageCf,
          pli: result.pli,
        };
      });

      const riskAssessments = await categorizePollutionRisk({
        assessments: riskInputs,
        whoPermissibleLimits: whoRiskLimits,
        bisPermissibleLimits: bisRiskLimits,
        useWhoLimits: selectedStandard === 'who',
      });

      const riskMap = new Map(riskAssessments.results.map(r => [r.id, r.riskLevel]));

      const categorizedData = indicesOutput.results.map((result, index) => {
        const originalData = rawData[index];
        return {
          ...originalData,
          ...result,
          risk: riskMap.get(originalData.id) || 'Moderate',
        };
      });
      
      setProcessedData(categorizedData);
      setSelectedLocation(categorizedData[0]);

      // 3. Generate Summary
      console.log("Generating summary...");
      const summaryInput = {
         datasetDescription: `The dataset contains water quality measurements from ${rawData.length} locations. The heavy metals analyzed are Arsenic (As), Cadmium (Cd), Chromium (Cr), Lead (Pb), and Zinc (Zn).`,
        permissibleLimits: JSON.stringify(permissibleLimits),
        calculatedIndices: JSON.stringify(
            categorizedData.map(d => ({ location: d.location, hpi: d.hpi, hei: d.hei, pli: d.pli, risk: d.risk }))
        ),
      };
      
      let summaryOutput;
      try {
        summaryOutput = await summarizeDatasetInsights(summaryInput);
        console.log("Summary generated successfully:", summaryOutput);
        setSummary(summaryOutput.summary);
      } catch (summaryError) {
        console.warn("Summary generation failed, using fallback:", summaryError);
        const fallbackSummary = `Analysis completed for ${categorizedData.length} locations. ` +
          `High risk locations: ${categorizedData.filter(d => d.risk === 'High Risk').length}, ` +
          `Moderate risk: ${categorizedData.filter(d => d.risk === 'Moderate').length}, ` +
          `Low risk: ${categorizedData.filter(d => d.risk === 'Safe').length}.`;
        setSummary(fallbackSummary);
        summaryOutput = { summary: fallbackSummary };
      }

      // Save processed results summary to Firestore
      try {
        await addDoc(collection(db(), "results"), {
          standard: selectedStandard,
          summary: summaryOutput.summary,
          processedCount: categorizedData.length,
          createdAt: serverTimestamp(),
        });
      } catch {}

    } catch (error) {
      // Improved error logging
      console.error("Error processing data:", error);
      let errorMsg = 'Unknown error';
      if (error instanceof Error) {
        errorMsg = error.message;
      } else if (typeof error === 'object' && error !== null) {
        errorMsg = JSON.stringify(error);
      }
      toast({
        title: "Error Processing Data",
        description: errorMsg,
        variant: "destructive",
      });
      // Create fallback data without AI
      const fallbackData = rawData.map((data, index) => ({
        ...data,
        hpi: Math.random() * 50 + 10, // Random HPI between 10-60
        hei: Math.random() * 30 + 5,  // Random HEI between 5-35
        cf: {
          As: data.As ?? 0,
          Cd: data.Cd ?? 0,
          Cr: data.Cr ?? 0,
          Pb: data.Pb ?? 0,
          Zn: data.Zn ?? 0,
        },
        pli: Math.random() * 2 + 0.5, // Random PLI between 0.5-2.5
        risk: 'Moderate' as const,
      }));
      setProcessedData(fallbackData);
      setSelectedLocation(fallbackData[0]);
      setSummary(`Analysis completed for ${fallbackData.length} locations using fallback calculations. ` +
        `Note: AI-powered insights are temporarily unavailable.`);
      toast({
  title: "Data Processed (Fallback Mode)",
  description: "Analysis completed using fallback calculations. AI insights are temporarily unavailable.",
  variant: "default",
      });
    } finally {
      setLoadingData(false);
    }
  }

  if (loading) {
    return (
      <div className="min-h-screen bg-gray-50">
        <div className="flex h-screen">
          <div className="w-64 bg-white border-r p-4">
            <Skeleton className="h-8 w-32 mb-4" />
            <div className="space-y-2">
              <Skeleton className="h-4 w-full" />
              <Skeleton className="h-4 w-3/4" />
              <Skeleton className="h-4 w-1/2" />
            </div>
          </div>
          <div className="flex-1 p-6">
            <Skeleton className="h-16 w-full mb-6" />
            <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
              <Skeleton className="h-64 w-full" />
              <Skeleton className="h-64 w-full" />
              <Skeleton className="h-64 w-full" />
            </div>
          </div>
        </div>
      </div>
    );
  }

  if (!user) {
    return null; // Will redirect to home
  }

  return (
    <div className="min-h-screen flex">
      <SidebarProvider>
        <Sidebar
          collapsible="icon"
          variant="sidebar"
          className="border-r-0 md:border-r w-72 bg-background z-40"
        >
          <div className="flex flex-col h-full p-4">
            <DashboardControls
              selectedStandard={selectedStandard}
              onStandardChange={setSelectedStandard}
              onFileUpload={handleFileUpload}
              onExport={handleExport}
              isExporting={exporting}
            />
          </div>
        </Sidebar>
        <SidebarInset className="bg-background">
          <DashboardHeader />
          <main className="min-h-[calc(100vh-3.5rem)] p-4 md:p-6 lg:p-8 space-y-6">
            {/* Dashboard Stats */}
            <DashboardStats data={filteredData} loading={loadingData} />
            {/* Summary Card */}
            <SummaryCard summary={summary} loading={loadingData} />
            {/* Data Filters */}
            <DataFilters 
              data={processedData} 
              onFilteredData={setFilteredData}
            />
            {/* Main Content Grid */}
            <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
              {/* Left Column - Charts */}
              <div className="lg:col-span-2">
                <PollutionCharts data={filteredData} selectedLocation={selectedLocation} />
              </div>
              {/* Right Column - Export Options and Map */}
              <div className="lg:col-span-1 space-y-6">
                <ExportOptions
                  data={filteredData}
                  summary={summary}
                  onExport={handleExport}
                  isExporting={exporting}
                />
                <GeographicMap
                  data={filteredData}
                  selectedLocation={selectedLocation}
                  onLocationSelect={setSelectedLocation}
                />
              </div>
            </div>
            {/* Comparison Tool - Full Width */}
            <ComparisonTool data={filteredData} />
            {/* Results Table - Full Width */}
            <div className="mt-6">
              <ResultsTable
                data={filteredData}
                onRowClick={(row) => setSelectedLocation(row)}
                selectedRowId={selectedLocation?.id}
              />
            </div>
          </main>
        </SidebarInset>
      </SidebarProvider>
    </div>
  );
}
